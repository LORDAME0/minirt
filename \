/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   handling_events.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: orahmoun <marvin@42.fr>                    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/03/17 17:52:24 by orahmoun          #+#    #+#             */
/*   Updated: 2022/03/20 22:49:22 by orahmoun         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "main.h"
#define PI 3.141592654
#define UP     126
#define DOWN   125
#define LEFT   123
#define RIGHT  124

		// mlx_put_image_to_window (mlx_info.mlx, mlx_info.win
							// , assets.imgs[0], pos[0].x, pos[0].y);
		// mlx_put_image_to_window (mlx_info.mlx, mlx_info.win
							// , assets.imgs[1], pos[1].x, pos[1].y);
		// mlx_put_image_to_window (mlx_info.mlx, mlx_info.win
							// , assets.imgs[2], pos[2].x, pos[2].y);
		// mlx_put_image_to_window (mlx_info.mlx, mlx_info.win
							// , assets.imgs[3], pos[3].x, pos[3].y);
	
uint_fast16_t  roundi(uint_fast16_t v)
{
	uint_fast16_t x;

	x = round(v);
	return x;
}

uint_fast16_t floori(uint_fast16_t v)
{
	uint_fast16_t x;

	x = floor(v);
	return x;
}


int_fast16_t min(int_fast16_t x, int_fast16_t y)
{
	return (x < y ? x : y);
}

int_fast16_t max(int_fast16_t x, int_fast16_t y)
{
	return (x > y ? x : y);
}

void	draw_circle(t_vec center, t_vec point, t_mlx info)
{
	float radius = vec_distance(center, point, sqrtf);
	int_fast16_t x = center.x - sqrtf(2) * (radius);
	int_fast16_t y = center.y - sqrtf(2) * (radius);

	printf("x == %d y == %d\n", x, y);
	vec_print("point", point);
	vec_print("center", center);
	printf ("%.2f\n", radius);
	while (y < (center.y + sqrtf(2) * (radius)))
	{
		while (x < (center.x + sqrtf(2) * (radius)))
		{
			// float dis1 = vec_distance((t_vec){{x, 0, 0}}, (t_vec){{center.x, 0, 0}}, sqrtf);
			// float dis2 = vec_distance((t_vec){{y, 0, 0}}, (t_vec){{center.y, 0, 0}}, sqrtf);
			float dis1 = x - center.x;
			float dis2 = y - center.y;
			if (dis1 * dis1 + dis2 * dis2 <=  radius * radius)
				mlx_pixel_put (info.win, info.win, x, y, 0x000000FF);
			x++;
		}
		x = 0;
		y++;
	}
}

// void	draw_line(t_vec v1, t_vec v2, t_mlx info, image img)
// {
//    uint_fast16_t x = 0;
//    uint_fast16_t y = 0;
//    float m = (v2.y - v1.y) / (v2.x - v1.x);
//    printf ("m == %f\n", m);
//    float b = v1.y - m * v1.x;
//
//    // printf ("v1 x == %.2f && y == %.2f\n", v1.x, v1.y);
//    // printf ("v2 x == %.2f && y == %.2f\n", v2.x, v2.y);
//    // printf ("y = %0.2f * x + %0.2f\n", m, b);
//    while (y < info.resolution.height) // || y < fabsf(b.y))
//    {
//       while (x < info.resolution.width) // || x < fabsf(b.x))
//       {
//          // if ((y == round(m * x + b) || y == floor(m * x + b))
//          // if(true
//                // && (vec_distance((t_vec){{x, y, 0}}, v1, sqrtf) <= vec_distance(v1, v2, sqrtf))
//                // && (vec_distance((t_vec){{x, y, 0}}, v2, sqrtf) <= vec_distance(v1, v2, sqrtf)))
//          // {
//             // mlx_pixel_put (info.win, info.win, x, y, 0x00FF00FF);
//             // mlx_put_image_to_window (info.mlx, info.win, img, x, y);
//          // }
//          if (powf(x - (500 / 2), 2) + powf(y - (500 / 2), 2) <= 250 * 2)
//             mlx_pixel_put (info.win, info.win, x, y, 0x00FF00FF);
//          else
//             mlx_pixel_put (info.win, info.win, x, y, 0x00000000);
//          x++;
//       }
//       x = 0;
//       y++;
//    }
// }

t_pos	move(t_pos pos, int keycode)
{
	t_pos	new_pos;

	if (keycode == UP_KEY)
		new_pos = vec_sum(pos, (t_vec){{0, -80, 0}});
	if (keycode == DOWN_KEY)
		new_pos = vec_sum(pos, (t_vec){{0, 80, 0}});
	if (keycode == LEFT_KEY)
		new_pos = vec_sum(pos, (t_vec){{-80, 0, 0}});
	if (keycode == RIGHT_KEY)
		new_pos = vec_sum(pos, (t_vec){{80, 0, 0}});
	return (new_pos);
}

t_pos	rotate(t_pos pos, int keycode, t_pos center)
{
	t_pos	new_pos;
	new_pos = vec_sub(pos, center);
		
		// ROTATE MATRIX
		float z = 10;
		float rad = (z * PI) / 180;
		printf ("z :: %f rad ::%f", z, rad);
		// around the x axis
		// t_matrix3 rotate_right = (t_matrix3){{
				// 1, 0, 0,
				// 0, cosf(rad), sinf(rad),
				// 0, -sinf(rad), cosf(rad)
		// }};
		// around the y axis
		t_matrix3 rotate_right = (t_matrix3){{
				cosf(rad), 0, -sinf(rad),
				0, 1, 0,
				sinf(rad), 0, cosf(rad)
		}};
		// around the z axis
		// t_matrix3 rotate_right = (t_matrix3){{
				// cosf(rad), sinf(rad), 0,
				// -sinf(rad), cosf(rad), 0,
				// 0, 0, 1
		// }};
		float zz = -10;
		float radd = (zz * PI) / 180;
		printf ("zz :: %f radd ::%f", zz, radd);
		t_matrix3 rotate_left = (t_matrix3){{
				cosf(radd), sinf(radd), 0,
				-sinf(radd), cosf(radd), 0,
				0, 0, 1
		}};
		mat3_print(rotate_left);
		mat3_print(rotate_right);

	if (keycode == RIGHT)
		new_pos = vec3_multi_mat3(new_pos, rotate_right);
	if (keycode == LEFT)
		new_pos = vec3_multi_mat3(new_pos, rotate_left);
	new_pos = vec_sum(new_pos, center);
	return (new_pos);
	
}

t_pos	scale(t_pos pos, int keycode, t_pos center)
{
	float			d;
	float			b;
	t_pos			new_pos;
	t_matrix3	scale_up;
	t_matrix3	scale_down;

	d = 1.2;
	b = 0.8;
	new_pos = vec_sub(pos, center);
	scale_up = (t_matrix3){{
		d, 0, 0,
		0, d, 0,
		0, 0, d
	}};
	scale_down = (t_matrix3){{
		b, 0, 0,
		0, b, 0,
		0, 0, b
	}};
	if (keycode == UP)
		new_pos = vec3_multi_mat3(new_pos, scale_up);
	if (keycode == DOWN)
		new_pos = vec3_multi_mat3(new_pos, scale_down);
	new_pos = vec_sum(new_pos, center);
	return (new_pos);
}

static int	key_hook(int keycode, t_data *data)
{
	static bool		begin;
	t_assets			assets;
	t_mlx				mlx_info;
	static t_pos	pos[1024];

	mlx_info = data->mlx_info;
	assets = data->assets;
	mlx_clear_window(mlx_info.mlx, mlx_info.win);
	if (keycode == ESC)
		exit (1);


	if (begin == false)
	{
		pos[0] = vec_init(100, 100, 0);
		pos[1] = vec_init(110, 110, 0);
		// pos[2] = vec_init(300, 200, 0);

		begin = true;
	}
	pos[3] = vec_centroid(pos[0], pos[1], pos[2]);
	if (keycode == UP_KEY
		|| keycode == DOWN_KEY
		|| keycode == RIGHT_KEY
		|| keycode == LEFT_KEY)
	{
		pos[0] = move(pos[0], keycode);
		pos[1] = move(pos[1], keycode);
		// pos[2] = move(pos[2], keycode);
		// pos[3] = move(pos[3], keycode);
	}

	if (keycode == RIGHT
		|| keycode == LEFT)
	{
		pos[0] = rotate(pos[0], keycode, pos[0]);
		pos[1] = rotate(pos[1], keycode, pos[0]);
		// pos[2] = rotate(pos[2], keycode, pos[3]);
	}
	if (keycode == UP
		|| keycode == DOWN)
	{
		pos[0] = scale(pos[0], keycode, pos[0]);
		pos[1] = scale(pos[1], keycode, pos[0]);
		// pos[2] = scale(pos[2], keycode, pos[3]);
	}
	// pos[3] = vec_centroid(pos[0], pos[1], pos[2]);

	// mlx_put_image_to_window (mlx_info.mlx, mlx_info.win
						// , assets.imgs[0], pos[0].x, pos[0].y);
	// mlx_put_image_to_window (mlx_info.mlx, mlx_info.win
						// , assets.imgs[1], pos[1].x, pos[1].y);
	// mlx_put_image_to_window (mlx_info.mlx, mlx_info.win
						// , assets.imgs[2], pos[2].x, pos[2].y);
	// mlx_put_image_to_window (mlx_info.mlx, mlx_info.win
						// , assets.imgs[3], pos[3].x, pos[3].y);

	draw_circle(pos[0], pos[1], data->mlx_info);
	mlx_put_image_to_window (mlx_info.mlx, mlx_info.win
						, assets.imgs[1], pos[1].x, pos[1].y);
	// draw_line(pos[0], pos[1], data->mlx_info, assets.imgs[1]);
	// draw_line(pos[1], pos[2], data->mlx_info, assets.imgs[1]);
	// draw_line(pos[2], pos[0], data->mlx_info, assets.imgs[1]);
	return (0);
}

static int destroy_window(t_data *data)
{
	mlx_destroy_window(data->mlx_info.mlx
							, data->mlx_info.win);
	exit (1);
}

void  handling_events(t_data *data)                      
{                                                                     
	t_mlx	mlx_info;

	mlx_info = data->mlx_info;
	mlx_hook (mlx_info.win, 2, 1L << 0, key_hook, data);
	mlx_hook (mlx_info.win, 17, 1L << 0, destroy_window, data);
}

		// panic (position.x + image_width > resolution.width
				// || position.y + image_height > resolution.height
					// , "out of bound"
					// ,__func__);
